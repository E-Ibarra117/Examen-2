# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SRpLBnOhDD9cdUZBTDcfnGEIsWH9WMf5
"""

# Commented out IPython magic to ensure Python compatibility.
"""
Created on Thursday Dec  8 22:57:32 2022

@author: Emilio Francisco Ibarra Gonzalez
"""

""" Image Object Meassurement """

from sklearn.cluster import KMeans
import numpy as np
from matplotlib import pyplot as plt
import cv2 as cv

import itertools

border_masks=[]
for i in range(3):
  vect[i]=1
  perm=itertools.permutations(vect)
  perm=list(set(perm))
  for item in perm:
    item=list(item)
    border_masks.append(item)

# %cd gdrive/MyDrive
# =============================================================================
# Leer imagen
# =============================================================================
img = cv.imread('Jit1.JPG')
img_rgb=cv.cvtColor(img, cv.COLOR_BGR2RGB)
plt.imshow(img_rgb)
plt.title("Original")
plt.show()
clusters=2

# =============================================================================
# Segmentacion por colores
# =============================================================================
img=cv.cvtColor(img, cv.COLOR_BGR2HSV)
vectorized = img.reshape((-1,3))
kmeans = KMeans(n_clusters=clusters, random_state = 0, n_init=5).fit(vectorized)
centers = np.uint8(kmeans.cluster_centers_)
segmented_data = kmeans.labels_.flatten()
Kimg = segmented_data.reshape((img.shape[:-1]))

plt.imshow(Kimg)
plt.title("Segmentacion por color")
plt.show()


# =============================================================================
# Filtros morfologicos
# =============================================================================
from skimage.morphology import (erosion, dilation, area_closing,)
square = np.array([[1,1,1],
                   [1,1,1],
                   [1,1,1]])

def multi_dil(im, num, element=square):
    for i in range(num):
        im = dilation(im, element)
    return im

def multi_ero(im, num, element=square):
    for i in range(num):
        im = erosion(im, element)
    return im

multi_dilated = multi_dil(Kimg,0)
area_closed = area_closing(multi_dilated, 50000)
multi_eroded = multi_ero(area_closed, 0)
image=np.uint8(multi_eroded)

plt.imshow(image)
plt.title("Filtros morfologicos")
plt.show()

# =============================================================================
# Obtencion de centroides, puntos de medicion y distancia
# =============================================================================
contours,hierarchy = cv.findContours(image,cv.RETR_LIST,cv.CHAIN_APPROX_SIMPLE)
count=1
for i in contours:
    if len(i)>500:
        x = [item[0][0] for item in i]
        y = [item[0][1] for item in i]
       
        x_prom=sum(x)//len(i)
        y_prom=sum(y)//len(i)
       
       
        x_dif=x-x_prom
        y_dif=y-y_prom
        theta= 0.5*np.arctan((2*sum(x_dif*y_dif))/sum((x_dif**2)-(y_dif**2)))
        V=(y-y_prom)-(np.tan(theta)*(x-x_prom))
        V=abs(V)
        Min = min(V)
        pos=np.where(V==Min)
        v = np.array((x[pos[0][0]], y[pos[0][0]]))
        u = np.array((x_prom,y_prom))
        dist_c=np.linalg.norm(v-u)
        Min0=np.inf
       
        for j in range(len(x)):  
            a = np.array((x[j],y[j]))
            dist=np.linalg.norm(v-a)
            if V[j]<Min0 and dist>dist_c:
                long=round(dist)
                Min0=V[j]
                tmp=j
        img_rgb = cv.line(img_rgb, (x[pos[0][0]],y[pos[0][0]]), (x[tmp],y[tmp]), color=(0, 0, 255), thickness=13)
        img_rgb = cv.circle(img_rgb, (x_prom,y_prom), radius=20, color=(255, 255, 0), thickness=-1)
        print("OBJETO",count)
        print(f'Coords centroide: ({x_prom},{y_prom})')
        print(f'Puntos de medicion:({x[pos[0][0]]},{y[pos[0][0]]}) ({x[tmp]},{y[tmp]})')
        print(f'Longitud: {long} pixeles')
        print()
        count += 1

plt.title("Mediciones")
plt.imshow(img_rgb)
plt.show()